{
  "last_update": "2025-12-14T12:10:00Z",
  "task_completed": "Edit League Settings in Admin Dashboard",
  "feature_logic": {
    "feature_name": "Selezione Dinamica della Lega",
    "summary": "Implementa una funzionalit√† che permette agli utenti che partecipano a pi√π leghe di passare da una all'altra in modo dinamico. La lega viene determinata tramite URL param (gestito da redirect server-side), eliminando il flicker durante l'idratazione SSR/Client.",
    "architectural_pattern": "Redirect Server-Side + URL Param Only. Quando l'URL non ha `?league=X`, il server (`page.tsx`) determina la prima lega dell'utente e fa redirect. Il client (`useLeague`) legge SOLO da URL param, mai da localStorage. Il localStorage viene usato solo per salvare la lega corrente (per il LeagueSelector).",
    "user_flow": [
      "1. L'utente, membro di pi√π leghe, visualizza la barra di navigazione (`navbar`).",
      "2. Nella navbar √® presente il nuovo componente `LeagueSelector`, che mostra la lega attualmente attiva.",
      "3. L'utente clicca sul selettore, che mostra un menu a tendina con l'elenco di tutte le leghe a cui partecipa.",
      "4. L'utente seleziona una nuova lega dall'elenco.",
      "5. L'hook `useLeague` aggiorna lo stato globale dell'applicazione con il nuovo ID della lega.",
      "6. Tutti i componenti che dipendono dalla lega attiva (es. la pagina delle aste, il budget) si ri-renderizzano automaticamente per mostrare i dati pertinenti alla nuova lega selezionata."
    ],
    "core_components_interaction": {
      "src/hooks/useLeague.ts": "Nuovo hook che rappresenta il cuore della logica. Gestisce lo stato della lega attiva, si occupa di leggerlo/scriverlo (es. da localStorage) e fornisce l'ID della lega corrente e la funzione per cambiarlo.",
      "src/components/league/LeagueSelector.tsx": "Nuovo componente UI che recupera la lista delle leghe dell'utente e le visualizza in un selettore. Utilizza l'hook `useLeague` per mostrare la selezione corrente e per aggiornarla.",
      "src/components/navbar.tsx": "Modificata per includere e renderizzare il componente `LeagueSelector`, rendendo la funzionalit√† accessibile da qualsiasi punto dell'applicazione.",
      "src/app/auctions/AuctionPageContent.tsx": "Componente chiave che √® stato modificato per utilizzare l'hook `useLeague`. Invece di ricevere un ID di lega statico, ora lo ottiene dinamicamente dall'hook, ricaricando i dati dell'asta ogni volta che l'utente cambia lega."
    },
    "database_interactions": [
      {
        "table": "league_participants",
        "operation": "SELECT",
        "description": "Recupera l'elenco di tutte le leghe a cui un utente √® iscritto per poterle mostrare nel selettore. Solitamente in join con `auction_leagues` per ottenere i nomi delle leghe."
      }
    ]
  },
  "penalty_system_logic": {
    "feature_name": "Sistema di Compliance e Penalit√† Automatiche",
    "summary": "Implementazione di un sistema che monitora la compliance della rosa degli utenti e applica automaticamente penalit√† in crediti se l'utente rimane non-compliant oltre un periodo di grazia. Le penalit√† vengono applicate direttamente al budget dell'utente e registrate come transazioni.",
    "architectural_pattern": "La logica √® integrata nella funzione `checkAndRecordCompliance` del servizio `penalty.service.ts`. Questa funzione viene invocata in vari punti dell'applicazione (es. login, eventi d'asta) e ora include un meccanismo per verificare la scadenza del grace period e applicare le penalit√† in modo sincrono all'interno della transazione database.",
    "user_flow": [
      "1. L'utente effettua il login o interagisce con un'asta, attivando un controllo di compliance.",
      "2. Se l'utente non √® compliant, un timer di grace period di 1 ora viene avviato/aggiornato.",
      "3. Se, al successivo controllo di compliance (dopo il login o un evento), il grace period √® scaduto e l'utente √® ancora non-compliant, viene applicata una penalit√† di 5 crediti.",
      "4. La penalit√† viene sottratta dal `current_budget` dell'utente e registrata nella tabella `budget_transactions`.",
      "5. Le penalit√† sono limitate a un massimo di 25 crediti totali per utente per lega.",
      "6. Se l'utente diventa compliant, il timer e il ciclo di penalit√† vengono resettati."
    ],
    "core_components_interaction": {
      "src/lib/db/services/penalty.service.ts": "La funzione `checkAndRecordCompliance` √® stata modificata per includere la logica di applicazione delle penalit√†. Questa funzione √® il punto centrale per la gestione dello stato di compliance e l'applicazione delle penalit√†.",
      "src/lib/db/services/bid.service.ts": "Invoca `checkAndRecordCompliance` quando un utente viene superato in un'asta o quando un'asta si conclude senza vittoria, per verificare immediatamente lo stato di compliance."
    },
    "database_interactions": [
      {
        "table": "user_league_compliance_status",
        "operation": "SELECT, INSERT, UPDATE",
        "description": "Memorizza lo stato di compliance dell'utente per lega, inclusi il timer di inizio del grace period, l'ultima penalit√† applicata e il conteggio delle penalit√† nel ciclo corrente."
      },
      {
        "table": "league_participants",
        "operation": "UPDATE",
        "description": "Il `current_budget` dell'utente viene ridotto quando viene applicata una penalit√†."
      },
      {
        "table": "budget_transactions",
        "operation": "INSERT, SELECT",
        "description": "Registra ogni penalit√† applicata come una transazione di tipo `penalty_requirement`. Viene anche usata per calcolare il totale delle penalit√† gi√† applicate."
      }
    ]
  },
  "scheduler_system_logic": {
    "feature_name": "Scheduler per Task Asincroni",
    "summary": "Implementa un sistema di scheduling centralizzato per eseguire task periodici in background, garantendo che operazioni critiche come la chiusura delle aste e la gestione dei timer vengano eseguite in modo tempestivo e affidabile.",
    "architectural_pattern": "Un processo singleton basato su `setInterval` viene avviato insieme al server Socket.IO. Questo scheduler esegue una funzione aggregatrice (`runBackgroundTasks`) a intervalli regolari (attualmente ogni 2 secondi). Questa funzione, a sua volta, invoca i vari servizi necessari (es. `processExpiredAuctionsAndAssignPlayers`).",
    "user_flow": [
      "1. L'applicazione si avvia, e con essa il server Socket.IO.",
      "2. Il server Socket.IO importa e avvia lo scheduler (`startScheduler`).",
      "3. Lo scheduler inizia immediatamente a eseguire `runBackgroundTasks` e poi ripete l'operazione ogni 2 secondi.",
      "4. Ad ogni esecuzione, `runBackgroundTasks` chiama la funzione per processare le aste scadute.",
      "5. Se un'asta √® scaduta (es. l'asta di Caprile), viene processata, il suo stato aggiornato a 'sold', e le notifiche vengono inviate ai client."
    ],
    "core_components_interaction": {
      "src/lib/scheduler.ts": "File centrale che contiene la logica dello scheduler, inclusa la funzione `startScheduler` e `runBackgroundTasks`.",
      "src/lib/db/services/bid.service.ts": "Contiene la logica di business per processare le aste scadute (`processExpiredAuctionsAndAssignPlayers`), che viene ora chiamata dallo scheduler.",
      "socket-server.ts": "Punto di ingresso che avvia lo scheduler, assicurando che sia sempre attivo quando l'applicazione √® in esecuzione."
    },
    "database_interactions": [
      {
        "table": "auctions",
        "operation": "SELECT, UPDATE",
        "description": "Lo scheduler interroga la tabella per trovare aste con `status = 'active'` e `scheduled_end_time <= now`, e poi aggiorna il loro stato a 'sold'."
      }
    ]
  },
  "ssr_implementation": {
    "feature_name": "Server-Side Rendering per Pagina Aste",
    "summary": "Implementazione del rendering lato server (SSR) per la pagina principale delle aste per migliorare le performance di caricamento iniziale e la SEO. I dati iniziali (manager, aste attive, budget, stati utente) vengono recuperati sul server e passati come props al componente client.",
    "architectural_pattern": "Server Component (`page.tsx`) che esegue il data fetching parallelo tramite servizi DB dedicati e passa i dati serializzati al Client Component (`AuctionPageContent.tsx`). Il Client Component inizializza il suo stato con questi dati e poi si sottoscrive agli aggiornamenti real-time via Socket.IO.",
    "technical_details": [
      "Backend (auction-league.service.ts): Aggiunta funzione `getLeagueManagersWithRosters` per aggregare dati manager, rose e aste attive.",
      "Backend (auction-states.service.ts): Aggiunta funzione `getUserAuctionStates` per recuperare gli stati d'asta specifici dell'utente.",
      "Frontend (page.tsx): Recupero dati server-side con gestione errori e redirect se necessario.",
      "Frontend (AuctionPageContent.tsx): Aggiornato per accettare `initial*` props e inizializzare `useState` con essi. Risolti conflitti di tipo tra interfacce server e client."
    ]
  },
  "auction_abandonment_logic": {
    "feature_name": "Abbandono Asta e Timer di Risposta",
    "summary": "Permette agli utenti di abbandonare volontariamente un'asta quando vengono superati, invece di attendere la scadenza del timer. Questo libera immediatamente i crediti bloccati e applica un cooldown di 48 ore per quel giocatore.",
    "architectural_pattern": "Gestito tramite l'endpoint `/api/leagues/[id]/players/[id]/response-action` e il servizio `response-timer.service.ts`. L'azione 'fold' triggera la funzione `abandonAuction`.",
    "user_flow": [
      "1. L'utente riceve una notifica di superamento offerta.",
      "2. Apre il modale di risposta e clicca su 'Abbandona'.",
      "3. Il frontend invia una richiesta POST con action='fold'.",
      "4. Il backend verifica che l'utente abbia un timer attivo e non sia gi√† in cooldown.",
      "5. Se valido, l'asta viene abbandonata per l'utente, i crediti sbloccati, e viene registrata una transazione 'auction_abandoned'.",
      "6. Viene applicato un cooldown di 48 ore per quel giocatore."
    ],
    "database_interactions": [
      {
        "table": "budget_transactions",
        "operation": "INSERT",
        "description": "Registra l'abbandono con tipo 'auction_abandoned'. Richiede `auction_league_id`."
      },
      {
        "table": "user_auction_cooldowns",
        "operation": "INSERT",
        "description": "Crea un record di cooldown per l'utente e il giocatore."
      }
    ]
  },
  "infinite_loop_fix": {
    "feature_name": "Ottimizzazione Loop Notifiche Compliance",
    "summary": "Risoluzione di un bug critico che causava un loop infinito di notifiche e riconnessioni socket. Il fix coinvolge sia il backend (emissione condizionale) che il frontend (gestione dipendenze useEffect).",
    "architectural_pattern": "Backend: Conditional Event Emission. Frontend: Ref Ref-based State Tracking.",
    "technical_details": [
      "Frontend (AuctionPageContent.tsx): Sostituito `useState` con `useRef` per tracciare l'ultima notifica ricevuta, rimuovendo la dipendenza che causava il re-rendering e la riconnessione al socket ad ogni evento."
    ]
  },
  "default_bid_logic_fix": {
    "feature_name": "Correzione Default Bid Amount",
    "summary": "Risolto un problema per cui il modale di offerta rapida (`QuickBidModal`) non mostrava il valore corretto (offerta attuale + 1) quando si tentava di rilanciare su un'asta attiva avviata da un altro utente.",
    "technical_details": [
      "Backend (player.service.ts): Aggiornata la query `getPlayers` per includere il campo `current_highest_bid_amount` dalla tabella `auctions` come `current_bid` per i giocatori in stato 'active_auction'.",
      "Frontend (CallPlayerInterface.tsx): Aggiornata l'interfaccia `ApiPlayer` e la funzione di mapping `refreshPlayersData` per leggere `current_bid` dall'API e passarlo allo stato del componente.",
      "Frontend (QuickBidModal.tsx): Aggiornata la logica di inizializzazione per usare `currentBid + 1` come valore di default quando disponibile."
    ]
  },
  "socket_room_fix": {
    "feature_name": "Fix Connessione Stanze Socket.IO",
    "summary": "Risolto un problema critico per cui il client non riceveva eventi real-time perch√© il server Socket.IO ascoltava eventi con nomi diversi ('join-league-room') da quelli emessi dal client ('join-room').",
    "technical_details": [
      "Backend (socket-server.ts): Aggiunti handler generici `join-room` e `leave-room` per supportare le chiamate del client.",
      "Frontend (AuctionPageContent.tsx): Corretta la gestione della risposta di `fetchUserAuctionStates` per prevenire crash client-side."
    ]
  },
  "ui_optimization": {
    "feature_name": "Ottimizzazione Modale Avvio Asta",
    "summary": "Migliorata la reattivit√† dell'interfaccia rimuovendo un refresh dati bloccante prima dell'apertura del modale di avvio asta.",
    "technical_details": [
      "Frontend (CallPlayerInterface.tsx): Rimossa la chiamata `refreshPlayersData()` prima di `setIsStartAuctionModalOpen(true)`. Il modale ora si apre istantaneamente usando i dati locali."
    ]
  },
  "server_actions_implementation": {
    "feature_name": "Server Actions per Interazioni Asta",
    "summary": "Migrazione delle interazioni critiche dell'asta (offerte, creazione asta, abbandono) dalle API Routes alle Server Actions di Next.js. Questo migliora la type safety, riduce il codice client-side e centralizza la logica di validazione e gestione errori.",
    "architectural_pattern": "Le Server Actions (`placeBidAction`, `abandonAuctionAction`) sono definite in `src/lib/actions/auction.actions.ts`. I componenti client (`AuctionPageContent`, `CallPlayerInterface`, `QuickBidModal`) importano e invocano direttamente queste funzioni asincrone, gestendo il risultato tipizzato (`ActionResponse`).",
    "technical_details": [
      "Server Action (placeBidAction): Gestisce sia la creazione di nuove aste che le offerte su aste esistenti, incapsulando la logica di business di `bid.service.ts`.",
      "Server Action (abandonAuctionAction): Gestisce l'abbandono di un'asta attiva.",
      "Client Integration: I componenti UI invocano le actions e gestiscono i feedback (successo/errore) tramite toast notifications, eliminando la necessit√† di `fetch` manuali."
    ]
  },
  "budget_verification_logic": {
    "feature_name": "Verifica e Debug del Budget",
    "summary": "Implementazione di strumenti di debug e correzione di bug critici nella gestione dei crediti bloccati (`locked_credits`). Il sistema garantisce che la somma di `disponibili + bloccati + spesi` sia sempre uguale al budget iniziale meno le penalit√†.",
    "architectural_pattern": "API Endpoint protetto (`/api/debug/budget-verification`) accessibile solo agli admin, che esegue query SQL dirette per aggregare i dati da diverse tabelle. Pagina di debug (`/debug/budget`) per visualizzare i risultati.",
    "technical_details": [
      "Bug Fix (Double Unlock): Risolto un problema in `bid.service.ts` dove i crediti degli auto-bid venivano sbloccati due volte (una volta quando superati, e di nuovo alla chiusura dell'asta), causando valori negativi.",
      "Bug Fix (Abandon Unlock): Risolto un problema in `auction-states.service.ts` dove l'abbandono di un'asta sbloccava erroneamente crediti per offerte manuali (che non bloccano crediti) o duplicava lo sblocco per auto-bid.",
      "Verifica: La formula `Iniziale = Disponibili + Bloccati + Spesi (giocatori) + Penalit√†` √® ora verificata e consistente."
    ],
    "database_interactions": [
      {
        "table": "league_participants",
        "operation": "SELECT, UPDATE",
        "description": "Lettura per verifica budget e aggiornamento `locked_credits` con controlli di sicurezza (`MAX(0, ...)`)."
      },
      {
        "table": "auto_bids",
        "operation": "SELECT",
        "description": "Verifica dello stato `is_active` per prevenire doppi sblocchi."
      }
    ]
  },
  "privacy_logic": {
    "feature_name": "Privacy dei Dati Sensibili (Locked Credits)",
    "summary": "Implementazione di regole di visibilit√† per impedire agli utenti di vedere i crediti bloccati (e quindi dedurre le auto-bid attive) degli avversari.",
    "architectural_pattern": "Sanitizzazione dei dati a livello API e SSR, e logica condizionale nella UI.",
    "technical_details": [
      "API (/api/leagues/[id]/managers): I campi `locked_credits` vengono impostati a 0 per tutti gli utenti diversi dal richiedente.",
      "SSR (page.tsx): I dati iniziali dei manager vengono sanitizzati prima di essere passati al Client Component.",
      "UI (ManagerColumn.tsx): Se `!isCurrentUser`, il campo 'Bloccati' mostra '-' e il campo 'Disponibili' mostra il 'Residuo Teorico' (Totale - Spesi) invece del reale disponibile."
    ]
  },
  "players_page_refinement": {
    "feature_name": "Refactoring UI Pagina Giocatori e Ottimizzazione Performance",
    "summary": "Riprogettazione dell'interfaccia di ricerca giocatori per migliorare l'usabilit√† e l'efficienza dello spazio, e ottimizzazione critica delle performance di caricamento.",
    "architectural_pattern": "UI: Sostituzione di filtri a griglia con una Toolbar compatta (Popover + Sheet). Performance: Batch data fetching per eliminare query N+1.",
    "technical_details": [
      "UI (PlayerFilterBar.tsx): Nuovo componente compatto che utilizza Popover per i filtri comuni e uno Sheet laterale per i filtri avanzati, risparmiando il 60% di spazio verticale.",
      "UI (PlayerSearchCard.tsx): Adozione del sistema colori pastello (coerente con la pagina Aste) per i ruoli dei giocatori.",
      "Performance (API): Risolto problema N+1 query nell'endpoint `/api/leagues/[id]/players-with-status`. I cooldown utente vengono ora recuperati in un'unica query batch invece che per ogni singolo giocatore, riducendo le query da N+4 a 5 costanti."
    ],
    "database_interactions": [
      {
        "table": "user_player_preferences",
        "operation": "SELECT",
        "description": "Query batch ottimizzata per recuperare tutti i cooldown attivi dell'utente in una sola chiamata."
      }
    ]
  },
  "dashboard_ui_improvements": {
    "feature_name": "Miglioramento UI Dashboard Aste",
    "summary": "Restyling completo della dashboard delle aste per migliorare l'estetica e l'esperienza utente. Introdotto un design 'glassmorphism', una nuova palette colori pastello per i ruoli, e animazioni per gli aggiornamenti in tempo reale.",
    "architectural_pattern": "UI-only update: utilizzo di Tailwind CSS e `tailwindcss-animate` per transizioni e animazioni senza aggiungere nuove dipendenze.",
    "technical_details": [
      "ManagerColumn.tsx: Aggiornato con card in stile glassmorphism, nuovi colori per i ruoli (Amber, Emerald, Sky, Rose) e dashboard budget ridisegnata.",
      "AuctionRealtimeDisplay.tsx: Aggiunte animazioni 'pop' al cambio offerta e migliorata la visualizzazione del timer e dello stato 'Sold'.",
      "BiddingInterface.tsx: Migliorato il feedback visivo dei pulsanti di offerta rapida."
    ]
  },
  "players_page_pagination": {
    "feature_name": "Ottimizzazione Pagina Giocatori (Paginazione Server-Side)",
    "summary": "Implementazione della paginazione e del filtraggio lato server per la pagina di ricerca giocatori, riducendo drasticamente il carico iniziale e migliorando le performance.",
    "architectural_pattern": "API Paginata + Frontend State Management. L'API accetta parametri `page`, `limit` e filtri, restituendo solo il sottoinsieme di dati richiesto.",
    "technical_details": [
      "API (/api/leagues/[id]/players-with-status): Aggiornata per supportare paginazione (LIMIT/OFFSET) e filtri dinamici (WHERE clause).",
      "Frontend (PlayerSearchInterface.tsx): Implementata gestione stato paginazione, debouncing della ricerca e aggiornamento dati al cambio pagina/filtri.",
      "Linting: Risolti errori di linting (prefer-const, prefer-template, no-explicit-any) nell'API route."
    ],
    "database_interactions": [
      {
        "table": "players",
        "operation": "SELECT",
        "description": "Query principale con LIMIT/OFFSET e filtri dinamici."
      },
      {
        "table": "players",
        "operation": "COUNT",
        "description": "Query separata per ottenere il numero totale di risultati per la paginazione."
      }
    ]
  },
  "optimization_logic": {
    "feature_name": "Next.js 16 Readiness & React Compiler",
    "summary": "Attivazione sperimentale del React Compiler (disponibile in Next.js 15) per ottimizzare automaticamente il rendering dei componenti e preparare il codice per Next.js 16.",
    "architectural_pattern": "Configurazione build-time in `next.config.mjs`.",
    "technical_details": [
      "Configuration: Abilitato `experimental.reactCompiler` in `next.config.mjs`.",
      "Dependencies: Aggiunto `babel-plugin-react-compiler` come devDependency.",
      "Verification: Build di produzione verificata con successo."
    ]
  },
  "empty_db_logic": {
    "feature_name": "Gestione Database Vuoto",
    "summary": "Implementata gestione errori per database giocatori vuoto e patch per loop infinito legato all'inizializzazione della lega.",
    "technical_details": [
      "Frontend (CallPlayerInterface.tsx): Aggiunto stato `hasNoPlayers`.",
      "Frontend (useLeague.ts): Inizializzazione sincrona per prevenire race condition."
    ]
  },
  "infinite_loop_fix_v2": {
    "feature_name": "Risoluzione Loop Rendering Asta",
    "summary": "Corretto un problema di dipendenze nel `useEffect` di `AuctionPageContent.tsx` che causava un refresh infinito dei dati della lega quando la lunghezza dell'array dei manager cambiava (es. durante il caricamento iniziale).",
    "technical_details": [
      "Frontend (AuctionPageContent.tsx): Rimosse `managers.length` e `isLoading` dalle dipendenze del `useEffect` di inizializzazione, stabilizzando il ciclo di caricamento dati."
    ]
  },
  "player_filter_fix": {
    "feature_name": "Correzione Filtri Giocatori",
    "summary": "Risolto un problema per cui i filtri (Titolari, Integrit√†, ecc.) nella schermata di chiamata giocatore non producevano risultati perch√© i campi corrispondenti dal database venivano ignorati dal frontend.",
    "technical_details": [
      "Frontend (CallPlayerInterface.tsx): Aggiornata l'interfaccia `ApiPlayer` per includere `is_starter`, `is_favorite`, `integrity_value`, `has_fmv`.",
      "Frontend (CallPlayerInterface.tsx): Aggiornata la logica di mapping dei dati per utilizzare i valori effettivi restituiti dall'API invece di valori di default hardcoded."
    ]
  },
  "infinite_scroll_dropdown": {
    "feature_name": "Infinite Scroll Dropdown Giocatori",
    "summary": "Implementata la funzionalit√† di caricamento infinito (infinite scroll) nel menu a tendina di selezione dei giocatori per rimuovere il limite rigido di 50 risultati.",
    "technical_details": [
      "Frontend (CallPlayerInterface.tsx): Aggiunto stato `visibleCount` e `IntersectionObserver` su un elemento 'loader' in fondo alla lista.",
      "Frontend (CallPlayerInterface.tsx): La lista viene renderizzata dinamicamente a blocchi di 50 elementi man mano che l'utente scorre verso il basso."
    ]
  },
  "user_preferences_fix": {
    "feature_name": "Integrazione Preferenze Utente nei Filtri",
    "summary": "Risolto un problema per cui i filtri 'Preferiti' e 'Titolari' nella pagina Asta non funzionavano perch√© il servizio non recuperava le preferenze specifiche dell'utente, ma solo i default globali.",
    "technical_details": [
      "Backend (player.service.ts): Aggiornata la query `getPlayers` per eseguire una `LEFT JOIN` con la tabella `user_player_preferences` quando viene fornito un `userId`.",
      "Backend (player.service.ts): Utilizzo di `COALESCE` per dare priorit√† alle preferenze utente rispetto ai valori di default.",
      "API (/api/players): Aggiornata per estrarre il `userId` dalla sessione corrente e passarlo al servizio."
    ]
  },
  "auction_bug_fixes": {
    "feature_name": "Fix Bug Asta e Foto Giocatori",
    "summary": "Risolti diversi bug critici nella pagina delle aste: il pulsante 'Rilancia' non funzionante, le foto dei giocatori mancanti e un errore 404 nell'API di auto-bid.",
    "technical_details": [
      "Frontend (ManagerColumn.tsx): Implementata la gestione dell'evento `onOpenBidModal` per il pulsante 'Rilancia' e corretta la formattazione dell'URL nella chiamata fetch per l'auto-bid.",
      "Frontend (AuctionPageContent.tsx): Centralizzata la logica di apertura del modale di offerta (`StandardBidModal`) e passato l'handler ai componenti figli.",
      "Frontend Utils (utils.ts): Creata la funzione `getPlayerImageUrl` con logica di fallback su URL standard Fantacalcio.",
      "Frontend (AuctionRealtimeDisplay.tsx, ManagerColumn.tsx, AuctionPlayerCard.tsx): Integrato `getPlayerImageUrl` per garantire la visualizzazione delle foto.",
      "Backend (player-import.service.ts): Aggiornata la logica di importazione per salvare l'URL della foto nel database se mancante nel file sorgente."
    ]
  },
  "player_card_alignment_fix": {
    "feature_name": "Correzione Allineamento Card Giocatori",
    "summary": "Risolto un problema di allineamento nelle card dei giocatori nella rosa dei manager. Il puntino colorato indicatore del ruolo causava disallineamenti quando posizionato prima del nome del giocatore. Inoltre, il prezzo di acquisto e l'icona lucchetto per i giocatori assegnati non erano allineati correttamente a destra.",
    "technical_details": [
      "Frontend (ManagerColumn.tsx - AssignedSlot): Spostato il puntino colorato del ruolo da prima a dopo il nome del giocatore. Rimosso il margine `mr-2` non necessario. Assicurato che il prezzo e l'icona lucchetto siano allineati a destra usando `flex-shrink-0` e `gap-2`.",
      "Frontend (ManagerColumn.tsx - ResponseNeededSlot): Spostato il puntino colorato del ruolo da prima a dopo il nome del giocatore per coerenza con gli altri slot.",
      "Frontend (ManagerColumn.tsx - InAuctionSlot): Spostato il puntino colorato del ruolo da prima a dopo il nome del giocatore. Rimosso il margine `mr-2` non necessario.",
      "Benefici: Layout pi√π pulito e coerente tra tutti i tipi di slot (assegnati, in asta, risposta necessaria). Migliore allineamento visivo del prezzo e delle icone a destra."
    ]
  },
  "budget_dashboard_redesign": {
    "feature_name": "Ridisegno Dashboard Crediti con Doppio Indicatore Disponibilit√†",
    "summary": "Implementata una nuova dashboard crediti che distingue chiaramente tra crediti disponibili senza rilanci (DISPONIBILI) e crediti realmente disponibili considerando gli auto-bid (DISP. AUTO-BID). Il sistema ora mostra 4 indicatori per l'utente corrente e 2 per gli altri utenti, garantendo privacy degli auto-bid.",
    "architectural_pattern": "Dashboard condizionale con calcoli differenziati per utente corrente e altri utenti. Per l'utente corrente: 4 colonne (DISPONIBILI, SPESI, DISP. AUTO-BID, AUTO-BID). Per altri: 2 colonne (RESIDUO, SPESI).",
    "user_flow": [
      "1. L'utente corrente visualizza la propria dashboard con 4 indicatori di budget.",
      "2. DISPONIBILI mostra i crediti disponibili se non ci sono rilanci sulle offerte correnti (include offerte manuali + auto-bid al prezzo corrente).",
      "3. SPESI mostra i crediti definitivamente spesi (giocatori assegnati + penalit√†).",
      "4. DISP. AUTO-BID (privato, icona üîí) mostra i crediti realmente disponibili considerando il massimo degli auto-bid.",
      "5. AUTO-BID (privato, icona üîí) mostra il totale dei crediti impegnati in auto-bid attivi.",
      "6. Gli altri utenti vedono solo RESIDUO (budget teorico) e SPESI, senza informazioni sugli auto-bid."
    ],
    "core_components_interaction": {
      "src/components/auction/ManagerColumn.tsx": "Componente principale modificato per implementare i nuovi calcoli budget e la UI condizionale. Calcola `currentWinningBidsAmount` sommando tutte le offerte correnti dove l'utente √® vincente (auto-bid + manuali). Implementa formule: SPESI = giocatori + penalit√†, DISPONIBILI = totale - spesi - offerte vincenti, DISP. AUTO-BID = totale - spesi - auto-bid, RESIDUO = totale - spesi."
    },
    "technical_details": [
      "Calcolo Budget: Aggiunta variabile `assignedPlayersCredits` per sommare solo i giocatori assegnati (esclude penalit√† dal calcolo iniziale).",
      "Calcolo Budget: Aggiunta variabile `currentWinningBidsAmount` che filtra `activeAuctions` per trovare tutte le aste dove `current_highest_bidder_id === manager.user_id` e somma i `current_highest_bid_amount`.",
      "Formula SPESI: `assignedPlayersCredits + validTotalPenalties` - ora le penalit√† sono incluse negli spesi.",
      "Formula DISPONIBILI: `validTotalBudget - spesi - currentWinningBidsAmount` - considera le offerte correnti visibili a tutti.",
      "Formula DISP. AUTO-BID: `validTotalBudget - spesi - autoBid` - considera il massimo impegnato in auto-bid (privato).",
      "Formula RESIDUO (altri utenti): `validTotalBudget - spesi` - budget teorico senza considerare auto-bid.",
      "UI: Dashboard condizionale con `isCurrentUser ? (4 colonne) : (2 colonne)`.",
      "UI: Campi privati (DISP. AUTO-BID, AUTO-BID) hanno sfondo colorato (ambra/blu) e icona üîí.",
      "UI: Tooltip esplicativi su ogni campo per chiarire il significato.",
      "Privacy: Gli auto-bid rimangono completamente nascosti agli altri utenti."
    ]
  },
  "edit_league_settings_logic": {
    "feature_name": "Modifica Impostazioni Lega in Admin Dashboard",
    "summary": "Permette all'admin di modificare le impostazioni della lega (Budget, Timer, Tipo Lega) direttamente dal dashboard quando la lega √® in stato 'participants_joining'. Se il budget viene modificato, il sistema aggiorna automaticamente il budget di tutti i partecipanti esistenti.",
    "architectural_pattern": "Server Action + Popover UI. Ogni card statistica ha un'icona di modifica che apre un Popover con un form. Il form invia i dati a una Server Action che valida e aggiorna il database.",
    "user_flow": [
      "1. L'admin apre il dashboard di gestione della lega.",
      "2. Se la lega √® in stato 'participants_joining', le card Budget, Timer e Tipo mostrano un'icona di modifica (matita).",
      "3. L'admin clicca sull'icona e appare un Popover con un campo di input.",
      "4. L'admin inserisce il nuovo valore e clicca 'Salva'.",
      "5. Il sistema valida il valore e aggiorna il database.",
      "6. Se il budget √® stato modificato, anche il current_budget di tutti i partecipanti viene aggiornato.",
      "7. Una transazione di budget viene registrata per tracciabilit√†.",
      "8. La UI si aggiorna mostrando il nuovo valore."
    ],
    "core_components_interaction": {
      "src/components/admin/EditLeagueSetting.tsx": "Componente Client che gestisce il form di modifica. Supporta input numerici, testuali e select dropdown.",
      "src/lib/actions/league.actions.ts": "Contiene la Server Action `updateLeagueSettingAction` che valida e processa la richiesta.",
      "src/lib/db/services/auction-league.service.ts": "Contiene la funzione `updateLeagueSettingForParticipantsJoining` che esegue le query SQL in transazione.",
      "src/app/admin/leagues/[leagueId]/dashboard/page.tsx": "Dashboard modificata per integrare le icone di modifica nelle card statistiche."
    },
    "database_interactions": [
      {
        "table": "auction_leagues",
        "operation": "UPDATE",
        "description": "Aggiorna il campo specificato (name, initial_budget_per_manager, timer_duration_minutes, league_type, slots_*)."
      },
      {
        "table": "league_participants",
        "operation": "UPDATE",
        "description": "Se il budget cambia, aggiorna il current_budget di tutti i partecipanti."
      },
      {
        "table": "budget_transactions",
        "operation": "INSERT",
        "description": "Registra una transazione 'admin_budget_increase' o 'admin_budget_decrease' per ogni partecipante."
      }
    ],
    "technical_details": [
      "Validazione: Il sistema verifica che la lega sia in stato 'participants_joining' prima di permettere modifiche.",
      "Budget Sync: Quando il budget cambia, il sistema calcola la differenza (newBudget - oldBudget) e la applica a tutti i partecipanti.",
      "Transazioni: Tutte le operazioni sono eseguite in una transazione SQL per garantire consistenza.",
      "UI: Le icone di modifica sono visibili solo quando `status === 'participants_joining'`."
    ]
  },
  "production_timer_fix": {
    "feature_name": "Fix Critico Timer Produzione (Offline Handling)",
    "summary": "Risoluzione di un bug critico in produzione dove i timer di risposta partivano immediatamente (con scadenza 1 ora da SUBITO) anche se l'utente era offline o rediretto per inattivit√†. La logica √® stata corretta per creare timer PENDENTI che si attivano solo al ritorno dell'utente.",
    "technical_details": [
      "Root Cause: La funzione `handleBidderChange` in `auction-states.service.ts` inseriva manualmente un record nella tabella `user_auction_response_timers` con `response_deadline = now + 1h` e `status = 'pending'`, bypassando del tutto il controllo di presenza online.",
      "Fix: Sostituito l'inserimento manuale SQL con la chiamata alla funzione centralizzata `createResponseTimer` (da `response-timer.service.ts`).",
      "Logic: `createResponseTimer` verifica `isUserCurrentlyOnline`. Se TRUE -> attiva subito. Se FALSE -> crea timer pending con deadline NULL. Al login successivo, `activateTimersForUser` imposta la deadline a `loginTime + 1h`.",
      "Race Condition Fix: In `session.service.ts`, `recordUserLogin` ora passa il timestamp `now` direttamente a `activateTimersForUser`, evitando che una query concorrente legga un vecchio `session_start` prima che la transazione di login sia committata."
    ],
    "core_components_interaction": {
      "src/lib/db/services/auction-states.service.ts": "Rimosso INSERT manuale, importata e usata `createResponseTimer`.",
      "src/lib/db/services/response-timer.service.ts": "Aggiornata `activateTimersForUser` per accettare un timestamp opzionale per evitare race conditions.",
      "src/lib/db/services/session.service.ts": "Aggiornata `recordUserLogin` per usare `REPLACE INTO` (atomic upsert) e passare il timestamp preciso al timer service."
    }
  }
}
